// 15章　ポインタ変数の仕組み

/* メモリとは
   超巨大な一列ロッカー 1か0のオンかオフかの状態
   メモリ2GBで21億以上のロッカー 荷物あり1 なし0
   コンピューターはロッカーに荷物を詰め込んで数値を記憶する
   コンピューターは数値を二進数で記憶
*/

/* ビットとは
   ビットとメモリは関係性が深い
   メモリは二進数だが1つ1つデータをやり取りするのは面倒
   なので、8個をまとめて使う
   2進数の、00000000~11111111の範囲を10進数で、0~255の範囲の数を使う
   CPUが一回で扱うメモリの二進数での桁数がビット数である
   1ビットは2進数一桁。CPUの処理単位が32ビット
*/

// 現在のコンピューターは32個のデータをひとまとめにして取り扱う
// 実際には8個ずつに仕分けされてそれぞれに番号が付けられている。
// 8ビット単位で扱う 8ビット = 1バイト 8ビットは都合がよい 0~255
// 32ビットの範囲内で番号を割り当てる
// 2進数で、 
// 00000000000000000000000000000000~11111111111111111111111111111111 の範囲内 10進数で約42億番まで	

// 変数はメモリ上に存在する。メモリに番号付きで保存
// 番号ではわかりにくいので名前をつけている

// C言語の実態　デニスリッチーが自分たちで使うためだけに作った言語


// メモリの番号を表示する


#include<stdio.h>

int main(void)
{
	int i;
	printf("%p\n", &i);
	return 0;
}

// 0012FF80

// 数字は使用するパソコンとコンパイラによって異なる
// どの番号のメモリに割り当てるかはコンパイラ(正確にはリンカ)が決める
// 表示は16進数という表示形式を使う。10進数の1234056。
// 16進数と2進数は親和性がよいため使用する

// 2進数は2,4,8,16。10進数は 10,100,1000。16進数は16,256,4096
// なので10進数と2進数はかみ合わない 
// 両手の指で数えられるのは指一本を2進数1桁にすれば1024まで計算可能
// 2進数で数えると単純小型になる
	
// アドレス -変数につけられメモリ上の番号のこと-
// URLアドレスのアドレスと全く同じ意味である。変数の住所がアドレス

// 3つのint型変数のアドレスを表示する例

#include<stdio.h>

int main(void)
{
	int i1,i2,i3;
	printf("i1(%p)\n",&i1);
	printf("i2(%p)\n",&i2);
	printf("i3(%p)\n",&i3);
	return 0;
}

// i1(0012FF78) 10進数で1245048
// i2(0012FF7C) 10進数で1245052
// i3(0012FF80) 10進数で1245056

// 配列の番号 アドレスは変数につけられたロッカー番号
// 配列の場合は先頭に&は必要ない。配列の個々の要素は変数と同じ扱いなので必要
// int型変数には4番ずれの連番が割り当てられるint型のサイズが4バイトだからである
// char型は1バイト
#include<stdio.h

int main(void)
{
	int array[10];
	printf("array____(%p)\n",array);
	printf("array0\n",&array[0]);
	printf("array1\n",&array[1]);
	printf("array2\n",&array[2]);
	return 0;
}

// array___(0012FF5C) 10進数で1245020
// array[0]___(0012FF7C) 10進数で1245020
// array[1]___(0012FF80) 10進数で1245024
// array[2]___(0012FF64) 10進数で1245028

// 配列のトリックが暴かれる。実は配列は配列の最初の要素のアドレスを示すだけ
// 各要素を参照するときにつけた[0],[1]の要素番号は配列名のアドレス+要素番号のメモリを参照するという意味
// 最初のアドレスを決めておけば、番号を足し算するだけで変数が並ぶ状態を再現可能
// 要素番号が1の時4増えるのはint型のサイズが4バイトのためであるため

// &付き変数の正体 &は実は変数のアドレスを求める演算子です
// +やxなどと同じように何らかの計算を行うための記号なのです
// どんな変数でも&変数を使うとアドレスを求めることができる。メモリ上の番号がわかる

// 全ては値渡しである。引数で渡すのは数値である。値渡しと呼ぶ。
// 値渡し　関数に単なる数値として情報を渡す方法
// 変数を実引数に指定しても渡されるのは中身の数値である
// 変数の中身を直接変更する場合は困る。関数に渡すのはコピーに過ぎない。
// &演算子を使えばアドレスがわかる。
// そのメモリ上の番号を書き換えれば呼び出し側の変数を書き換えることができる

// 参照渡し　アドレスを渡す処理を言語の機能で自動で行う事です。
// C言語は値渡ししかできないが、アドレスを渡す事を慣習的に値渡しと呼ぶ

// scanf関数に&を付ける理由はCは値渡ししかできないので、
// 関数に変数に変数に記憶されたコピーしか渡せない。
// 変数のアドレスを数値として渡すためにscanfは&を付けている
// 配列は最初の要素のアドレスを表しているため配列名を渡せば&は不要

#include<stdio.h>

int main(void)
{
	char str[256];
	scanf("%s",&str[0]); // 0番の要素のアドレス
	printf'("%s\n",str);
	return 0;
}
// 配列名の代わりに要素0番のアドレスを与える事で同じ意味となる
// MARIO -> MARIO


#include<stdio.h>
	char str[256] = "DRAGON";
	scanf("%s",&str[6]); /* 6番の要素のアドレス */
	printf("%s\n",str);
	return 0;
}
// QUEST -> DRAGONQUEST
// 文字列は6番目から始まるため最初からの文字列と結合される


	// ポインタという単語　アドレスを記憶する変数
	// アドレスの値を記憶する変数をポインタと呼ぶが、実は正確ではない。
	// ポインタは総称であり、ポインタ型、ポインタ値、ポインタ変数がある
	
// ポインタ型 intやdoubleと同じような型。少し異なる
// ポインタ値 アドレスのこと
// ポインタ変数 ポインタ型で宣言されたポインタ値を記憶できる変数


// ポインタ型は他の型と合体させて使う int + ポイント型 double + ポイント型
// アドレスを記憶する変数の型。指定アドレスに記憶された数値を取り出すために存在


// ポインタ値はポインタ型の変数が記憶できる数値の事ですが、変数のアドレスの値の事。
// 多くのコンパイラではポインタ型は符号なしの整数値


// ポインタ変数とはポインタ型で宣言された実際の変数
// 変数のアドレスを事由に代入することが可能
// 更に記憶しているアドレスのメモリを読んだり書き換えたりする事ができる。
//
// ポインタ変数はポインタ変数モードと通常変数モードの二つのモードがある
// ポインタ変数モードはアドレスへの代入と足し算引き算のみ。アドレス記憶できれば良い
// 通常変数モードは切り替わった場合その性質は通常変数同様。

// ポインタ変数を使ってみる

#include<stdio.h>

int main(void)
{
	int *p;
	int* p;
}
// 多くの入門書で紹介されるポインタ変数宣言
// pという名s前のintへのポインタ型の変数を宣言する書き方
// 1つ目で*pというポインタ型 int型変数のアドレスを記憶するp
// 2つ目のp2は、普通のint型変数になってしまう。

// int* p1,p2
// 変数名の前に*を付ければポインタ変数を宣言する事ができる
// *がついていても、変数名はpとなる


// ポインタ変数にアドレスを代入する

int main(void)
{
	int *p
	int i;
	p = &i;

	printf("p = %p\n",p);
	printf("&i = %p\n",&i);
	return 0;
}
// ポインタ変数pを宣言し、変数iを宣言する。その後、
// 変数iのアドレスを&演算子を使ってポインタ変数pに代入している

// 結果　
// p = 0012FF80
// &i = 0012FF80


// ヌルポインタ
// ポインタ変数も宣言した直後はでたらめな値が代入されている
// その値が使用可能かは不明なのでバグになる
// そのため、C言語にはヌルポインタが用意されている
// NULLをポインタ変数に代入すればアドレスが代入されていないため、
// 使っていない状態であることを示せる
/*
   int *p = NULL; if p ==NULL
このようにすればpにアドレスが代入化されているかどうかを区別できる
*/

// ヌルポインタは0?
// int *p = 0;
// としてもヌルポインタが代入されるがNULLはNULLである


// 配列とポインタの関係

#include<stdio.h>

int getaverage(int *data);
// ポインタ型int変数data
int main(void)
{
    int average,array[10] = {15,78,98,85,17,35,42,15};
    average = getaverage(array);
    printf()"%d\n",average);
    return 0;
}

int getaverage(int * data)
{
	int i,average = 0;
	for(i = 0; i < 10; i++){
		average += data[i];
		/* ポインタ変数なのに? */
	}
	return average / 10;
}


// 不自然な部分はdata[i] 変数dataはポインタ変数であり配列ではない。
// しかし、配列番号により要素番号を指定することができる
// []の役割は、配列の要素番号を指定する演算子なのだが、
// その仕組みは単に、配列名というアドレスに足し算を行っているだけです
// 配列でなくてもアドレス値なら何でもよい

// []の記号の有無にかかわらず、配列名は配列の先頭要素へのアドレス（ポインタ値として扱われる)


/* 宣言時と数式の違い
配列を宣言する時には、[]で要素数を指定し、配列の要素を使うときには、[]で番号を指定する
実はこれら二つは全く別の記号である。
宣言時の[]は要素数を指定するという意味を持つが、数式の中の[]はアドレスに足し算をするという意

C言語の特徴として、似た使い方には同じ記号を使いたがる。そのため異なる意味に同じ記号を割り当てている。
*/

// ポインタ変数を配列のように使用する例

#include<stdio.h>

int main(void)
{
int *data;
int i,average = 0,array[10] =
{15,78,98,15,98,85,17,35,42,15};

data = array; // ポインタ変数に配列のアドレス代入

for(i = 0; i < 10; i++) {
	average += data[i];
	// 配列のように扱う事ができる
}

printf("%d\n",average / 10);
return 0;
// 実行結果
// 49

//普段、このようなややこしいようなコードを書く必要はないが、動的メモリ確保をするようになった際に必要となる

/* 配列とポインタは別物である
配列とポインタを多くの人が勘違いするが
配列とは多数の変数を順番付けでまとめて扱う方法であり、ポインタとは変数のショートカットを作る方法である似た動作に見えるのは配列の設計と関係がある。

C言語では配列を実現するための手段としてポインタを活用している。そのため配列ではポインタ変数と同等のことができてしまう。

ポインタと配列は混同しやすい。配列は多数の変数の先頭を示す固定された変数だが、ポインタ変数は好きな変数を代入することができ、好きなメモリ領域を使うことができる可変的な変数です。

*/
